#!/usr/bin/env bash 
set -eo pipefail

# Check if helm chartsnap plugin is installed
if ! helm plugin list | grep -q "chartsnap"; then
  echo "❌ helm chartsnap plugin is not installed"
  echo "Please install it by running:"
  echo "  helm plugin install https://github.com/jlandowner/helm-chartsnap"
  exit 1
fi

if ! helm plugin list | grep -q "cascade"; then
  echo "❌ helm cascade plugin is not installed"
  echo "Please install it by running:"
  echo "  helm plugin install https://github.com/origranot/helm-cascade"
  exit 1
fi

function usage() {
  cat <<EOF
A helper script for the helm-chartsnap plugin https://github.com/jlandowner/helm-chartsnap

Usage: $0 [COMMAND] [CHART (default: operator-wandb)]

Commands:
  build,              build the operator-wandb chart
  update,             execute chartsnap to update the snapshots
  run,                executes chartsnap to test helm changes
  generate-env-tests, generate environment expansion test from Chart.yaml and values.yaml
EOF
}

function build_chart() {
  local chart="$1"
  echo "Building $chart"
  helm cascade build "./charts/$chart"
}

function update_chart() {
  local chart="$1"
  local values_file="$2"
  echo "updating $chart snapshots"
  helm chartsnap -c "./charts/$chart" -u -f "$values_file"
}

function run_chart() {
  local chart="$1"
  local values_file="$2"
  echo "Checking $chart snapshot tests"
  helm chartsnap -c "./charts/$chart" -f "$values_file"
}

function generate_env_tests() {
  local chart="$1"
  local chart_yaml="./charts/$chart/Chart.yaml"
  local values_yaml="./charts/$chart/values.yaml"
  local output_file="./charts/$chart/templates/tests/test-env-expansion.yaml"
  
  echo "Generating environment expansion tests for $chart..."
  
  # Check if yq is installed
  if ! command -v yq &> /dev/null; then
    echo "❌ yq is not installed"
    echo "Please install it from https://github.com/mikefarah/yq"
    echo "  brew install yq"
    echo "  or download from https://github.com/mikefarah/yq/releases"
    exit 1
  fi
  
  # Check if jq is installed
  if ! command -v jq &> /dev/null; then
    echo "❌ jq is not installed"
    echo "Please install it:"
    echo "  brew install jq"
    echo "  or visit https://jqlang.github.io/jq/download/"
    exit 1
  fi
  
  # Get all wandb-base service aliases from Chart.yaml
  local services=$(yq eval '.dependencies[] | select(.name == "wandb-base") | .alias' "$chart_yaml")
  
  if [ -z "$services" ]; then
    echo "❌ No wandb-base dependencies found in $chart_yaml"
    exit 1
  fi
  
  echo "Found services: $(echo $services | tr '\n' ' ')"
  
  # Start building the test file
  cat > "$output_file" <<'EOF'
# This file is auto-generated by snapshots.sh generate-env-tests
# Do not edit manually - regenerate with: ./snapshots.sh generate-env-tests
apiVersion: v1
kind: Pod
metadata:
  name: "{{ include "wandb.fullname" . }}-test-env-expansion"
  labels:
    {{- include "wandb.labels" . | nindent 4 }}
  annotations:
    "helm.sh/hook": test
spec:
  containers:
    - name: env-expansion-test-anchor
      image: busybox:latest
      command: &env-expansion-test-command
        - sh
        - -c
        - |
          echo "Checking for unresolved \$(VARIABLE) references in environment..."
          echo ""
          
          # Check for $(VARIABLE) style references
          FOUND=$(env | grep '(' || true)
          
          if [ -n "$FOUND" ]; then
            echo "ERROR: Found \$(VARIABLE) references in environment:"
            echo "$FOUND"
            echo ""
            echo "This typically indicates one of two issues:"
            echo "1. ConfigMap values using \$(VAR) instead of Helm templating {{"{{"}} .Values... {{"}}"}}"
            echo "2. Environment variables referencing \$(VAR) that aren't set in the pod"
            echo ""
            echo "For ConfigMaps: Use Helm templating at template-render time."
            echo "For env vars: Ensure referenced variables are defined in a _*.tpl file"
            echo "             and included via envTpls in values.yaml."
            echo ""
            exit 1
          fi
          
          echo "SUCCESS: No unresolved \$(VARIABLE) references found."
          exit 0
EOF

  # Generate a container for each service
  local container_count=0
  for service in $services; do
    # Check if service has install flag (skip if not installable or always installed)
    local has_install=$(yq eval ".$service | has(\"install\")" "$values_yaml")
    
    # Check if service exists in values
    local service_exists=$(yq eval "has(\"$service\")" "$values_yaml")
    
    if [ "$service_exists" != "true" ]; then
      echo "  Skipping $service (not found in values.yaml)"
      continue
    fi
    
    echo "  Processing $service..."
    
    # Convert service name to lowercase for container name (RFC 1123 requirement)
    local container_name=$(echo "${service}-env-check" | tr '[:upper:]' '[:lower:]')
    
    # Start conditional block if service has install flag
    if [ "$has_install" == "true" ]; then
      # Use bracket notation for service names with hyphens
      echo "{{- if index .Values \"$service\" \"install\" }}" >> "$output_file"
    fi
    
    # Generate container section
    cat >> "$output_file" <<EOF
    - name: ${container_name}
      image: busybox:latest
EOF

    # Add envFrom section
    local has_env_from=$(yq eval ".$service | has(\"envFrom\")" "$values_yaml")
    if [ "$has_env_from" == "true" ]; then
      echo "      envFrom:" >> "$output_file"
      
      # Get raw envFrom entries and preserve Helm template syntax
      # Use process substitution to avoid subshell issues
      while IFS='|' read -r key type; do
        cat >> "$output_file" <<EOF
        - ${type}:
            name: {{ tpl "${key}" . }}
            optional: true
EOF
      done < <(yq eval ".${service}.envFrom" "$values_yaml" -o=json | jq -r 'to_entries | .[] | "\(.key)|\(.value)"')
    fi
    
    # Add env section
    echo "      env:" >> "$output_file"
    
    # Add envTpls - preserve the raw template strings
    local has_env_tpls=$(yq eval ".$service | has(\"envTpls\")" "$values_yaml")
    if [ "$has_env_tpls" == "true" ]; then
      # Read each envTpl entry and output it with indent directive
      while IFS= read -r tpl; do
        if [ -n "$tpl" ] && [ "$tpl" != "null" ]; then
          # Strip closing }} from template, add | indent 8, then add }} back
          # e.g., "{{ include \"wandb.downwardEnvs\" . }}" becomes "{{ include \"wandb.downwardEnvs\" . | indent 8 }}"
          tpl_with_indent=$(echo "$tpl" | sed 's/ }}$/ | indent 8 }}/')
          echo "$tpl_with_indent" >> "$output_file"
        fi
      done < <(yq eval ".${service}.envTpls[]" "$values_yaml" 2>/dev/null)
    fi
    
    # Add env entries using wandb-base helper
    local has_env=$(yq eval ".$service | has(\"env\")" "$values_yaml")
    if [ "$has_env" == "true" ]; then
      cat >> "$output_file" <<EOF
{{ include "wandb-base.env" (dict "env" (index .Values "$service" "env") "root" .) | indent 8 }}
EOF
    fi
    
    # Add test command - reference the anchor
    cat >> "$output_file" <<'EOF'
      command: *env-expansion-test-command
EOF

    # Close conditional block if service has install flag
    if [ "$has_install" == "true" ]; then
      echo "{{- end }}" >> "$output_file"
    fi
    
    container_count=$((container_count + 1))
  done
  
  # Close the pod spec
  cat >> "$output_file" <<'EOF'
  restartPolicy: Never
EOF
  
  echo "✅ Generated test file with $container_count service containers: $output_file"
  echo ""
  echo "To regenerate this file, run:"
  echo "  ./snapshots.sh generate-env-tests $chart"
}


function main() {
  local chart="operator-wandb"
  local values_dir="test-configs"

  if [ $# -eq 0 ]; then
    usage
    exit 1
  fi

  local func="$1"
  local target_chart="$2"

  if [ -n "$target_chart" ]; then
    chart="$target_chart"
  fi
  case "$func" in
    build)
      build_chart "$chart"
      ;;
    update)
      update_chart "$chart" "./$values_dir/$chart"
      ;;
    run)
      run_chart "$chart" "./$values_dir/$chart"
      ;;
    generate-env-tests)
      generate_env_tests "$chart"
      ;;
    *)
      usage
      exit 1
      ;;
  esac
}

main "$@"
