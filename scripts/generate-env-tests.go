package main

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
)

const (
	testImage = "us-docker.pkg.dev/wandb-production/public/busybox:stable-musl"
	testImagePullPolicy = "IfNotPresent"
)

type Chart struct {
	Dependencies []Dependency `yaml:"dependencies"`
}

type Dependency struct {
	Name  string `yaml:"name"`
	Alias string `yaml:"alias"`
}

type Values map[string]any

func main() {
	chart := flag.String("chart", "operator-wandb", "Chart name to generate tests for")
	flag.Parse()

	if err := generateTests(*chart); err != nil {
		fmt.Fprintf(os.Stderr, "❌ Error: %v\n", err)
		os.Exit(1)
	}
}

func generateTests(chartName string) error {
	baseDir, err := resolveBaseDir(chartName)
	if err != nil {
		return err
	}

	chartPath := filepath.Join(baseDir, "charts", chartName)
	chartYAML := filepath.Join(chartPath, "Chart.yaml")
	valuesYAML := filepath.Join(chartPath, "values.yaml")
	outputFile := filepath.Join(chartPath, "templates", "tests", "test-env-expansion.yaml")

	fmt.Printf("Generating environment expansion tests for %s...\n", chartName)

	chartData, err := loadChart(chartYAML)
	if err != nil {
		return fmt.Errorf("failed to load Chart.yaml: %w", err)
	}

	values, err := loadValues(valuesYAML)
	if err != nil {
		return fmt.Errorf("failed to load values.yaml: %w", err)
	}

	services := getWandbBaseServices(chartData)
	if len(services) == 0 {
		return fmt.Errorf("no wandb-base dependencies found in %s", chartYAML)
	}

	fmt.Printf("Found services: %s\n", strings.Join(services, " "))

	if err := generateTestFile(outputFile, services, values, chartName); err != nil {
		return fmt.Errorf("failed to generate test file: %w", err)
	}

	fmt.Printf("✅ Generated test file: %s\n", outputFile)
	fmt.Printf("\nTo regenerate this file, run:\n")
	fmt.Printf("  ./snapshots.sh generate-env-tests %s\n", chartName)

	return nil
}

func resolveBaseDir(chartName string) (string, error) {
	candidates := []string{".", ".."}
	for _, dir := range candidates {
		chartPath := filepath.Join(dir, "charts", chartName, "Chart.yaml")
		if _, err := os.Stat(chartPath); err == nil {
			return dir, nil
		}
	}
	return "", fmt.Errorf("Chart.yaml not found for chart %q in ./charts or ../charts", chartName)
}

func loadChart(path string) (*Chart, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var chart Chart
	if err := yaml.Unmarshal(data, &chart); err != nil {
		return nil, err
	}

	return &chart, nil
}

func loadValues(path string) (Values, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var values Values
	if err := yaml.Unmarshal(data, &values); err != nil {
		return nil, err
	}

	return values, nil
}

func getWandbBaseServices(chart *Chart) []string {
	var services []string
	for _, dep := range chart.Dependencies {
		if dep.Name == "wandb-base" && dep.Alias != "" {
			services = append(services, dep.Alias)
		}
	}
	return services
}

func toStringMap(v any) map[string]any {
	switch val := v.(type) {
	case map[string]any:
		return val
	case map[any]any:
		result := make(map[string]any)
		for k, v := range val {
			if keyStr, ok := k.(string); ok {
				result[keyStr] = v
			}
		}
		return result
	case Values:
		// Values is already map[string]any
		return map[string]any(val)
	default:
		return nil
	}
}

func generateTestFile(outputPath string, services []string, values Values, chartName string) error {
	// Create output directory if needed
	if err := os.MkdirAll(filepath.Dir(outputPath), 0755); err != nil {
		return err
	}

	f, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprintln(f, "# This file is auto-generated by snapshots.sh generate-env-tests")
	fmt.Fprintln(f, "# Do not edit manually - regenerate with: ./snapshots.sh generate-env-tests")
	fmt.Fprintln(f, "apiVersion: v1")
	fmt.Fprintln(f, "kind: Pod")
	fmt.Fprintln(f, "metadata:")
	fmt.Fprintln(f, `  name: "{{ include "wandb.fullname" . }}-test-env-expansion"`)
	fmt.Fprintln(f, "  labels:")
	fmt.Fprintln(f, "    {{- include \"wandb.labels\" . | nindent 4 }}")
	fmt.Fprintln(f, "  annotations:")
	fmt.Fprintln(f, `    "helm.sh/hook": test`)
	fmt.Fprintln(f, "spec:")
	fmt.Fprintln(f, "  containers:")

	writeAnchorContainer(f)

	containerCount := 0
	for _, service := range services {
		serviceConfig, exists := values[service]
		if !exists {
			fmt.Printf("  Skipping %s (not found in values.yaml)\n", service)
			continue
		}

		fmt.Printf("  Processing %s...\n", service)
		writeServiceContainer(f, service, serviceConfig)
		containerCount++
	}

	fmt.Fprintln(f, "  restartPolicy: Never")

	fmt.Printf("✅ Generated test file with %d service containers\n", containerCount)

	return nil
}

func writeAnchorContainer(f *os.File) {
	fmt.Fprintln(f, "    - name: env-expansion-test-anchor")
	fmt.Fprintf(f, "      image: %s\n", testImage)
	fmt.Fprintf(f, "      imagePullPolicy: %s\n", testImagePullPolicy)
	fmt.Fprintln(f, "      command: &env-expansion-test-command")
	fmt.Fprintln(f, "        - sh")
	fmt.Fprintln(f, "        - -c")
	fmt.Fprintln(f, "        - |")
	fmt.Fprintln(f, `          echo "Checking for unresolved \$(VARIABLE) references in environment..."`)
	fmt.Fprintln(f, `          echo ""`)
	fmt.Fprintln(f, "          ")
	fmt.Fprintln(f, "          # Check for $(VARIABLE) style references")
	fmt.Fprintln(f, "          FOUND=$(env | grep '$(' || true)")
	fmt.Fprintln(f, "          ")
	fmt.Fprintln(f, "          if [ -n \"$FOUND\" ]; then")
	fmt.Fprintln(f, `            echo "ERROR: Found \$(VARIABLE) references in environment:"`)
	fmt.Fprintln(f, `            echo "$FOUND"`)
	fmt.Fprintln(f, `            echo ""`)
	fmt.Fprintln(f, `            echo "This typically indicates one of two issues:"`)
	fmt.Fprintln(f, `            echo "1. ConfigMap values using \$(VAR) instead of Helm templating {{"{{"}} .Values... {{"}}"}}"`)
	fmt.Fprintln(f, `            echo "2. Environment variables referencing \$(VAR) that aren't set in the pod"`)
	fmt.Fprintln(f, `            echo ""`)
	fmt.Fprintln(f, `            echo "For ConfigMaps: Use Helm templating at template-render time."`)
	fmt.Fprintln(f, `            echo "For env vars: Ensure referenced variables are defined in a _*.tpl file"`)
	fmt.Fprintln(f, `            echo "             and included via envTpls in values.yaml."`)
	fmt.Fprintln(f, `            echo ""`)
	fmt.Fprintln(f, "            exit 1")
	fmt.Fprintln(f, "          fi")
	fmt.Fprintln(f, "          ")
	fmt.Fprintln(f, `          echo "SUCCESS: No unresolved \$(VARIABLE) references found."`)
	fmt.Fprintln(f, "          exit 0")
}

func writeServiceContainer(f *os.File, service string, config any) {
	configMap := toStringMap(config)
	if configMap == nil {
		fmt.Fprintf(os.Stderr, "Warning: %s config is not a map (type: %T)\n", service, config)
		return
	}

	hasInstall := false
	if _, exists := configMap["install"]; exists {
		hasInstall = true
		fmt.Fprintf(f, "{{- if index .Values \"%s\" \"install\" }}\n", service)
	}

	containerName := strings.ToLower(service + "-env-check")
	fmt.Fprintf(f, "    - name: %s\n", containerName)
	fmt.Fprintf(f, "      image: %s\n", testImage)
	fmt.Fprintf(f, "      imagePullPolicy: %s\n", testImagePullPolicy)

	if envFromRaw, exists := configMap["envFrom"]; exists {
		envFromMap := toStringMap(envFromRaw)
		if len(envFromMap) > 0 {
			keys := make([]string, 0, len(envFromMap))
			for key := range envFromMap {
				keys = append(keys, key)
			}
			sort.Strings(keys)

			fmt.Fprintln(f, "      envFrom:")
			for _, key := range keys {
				refTypeRaw := envFromMap[key]
				if refType, ok := refTypeRaw.(string); ok {
					fmt.Fprintf(f, "        - %s:\n", refType)
					fmt.Fprintf(f, "            name: {{ tpl \"%s\" . }}\n", key)
					fmt.Fprintln(f, "            optional: true")
				}
			}
		}
	}

	// Check if we have any env entries to write
	var envLines []string
	
	if envTplsRaw, exists := configMap["envTpls"]; exists {
		if envTpls, ok := envTplsRaw.([]any); ok {
			for _, tpl := range envTpls {
				if tplStr, ok := tpl.(string); ok {
					// Add | indent 8 before closing }}
					if strings.HasSuffix(tplStr, " }}") {
						tplStr = tplStr[:len(tplStr)-3] + " | indent 8 }}"
					}
					envLines = append(envLines, tplStr)
				}
			}
		}
	}

	if _, hasEnv := configMap["env"]; hasEnv {
		envLines = append(envLines, fmt.Sprintf("{{ include \"wandb-base.env\" (dict \"env\" (index .Values \"%s\" \"env\") \"root\" .) | indent 8 }}", service))
	}

	// Write env section - use empty list if no entries
	if len(envLines) == 0 {
		fmt.Fprintln(f, "      env: []")
	} else {
		fmt.Fprintln(f, "      env:")
		for _, line := range envLines {
			fmt.Fprintln(f, line)
		}
	}

	fmt.Fprintln(f, "      command: *env-expansion-test-command")

	if hasInstall {
		fmt.Fprintln(f, "{{- end }}")
	}
}
