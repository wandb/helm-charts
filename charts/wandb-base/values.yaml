# Default values for wandb-base.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

kind: Deployment

global:
  env: {}
  imagePullSecrets: []
  # DEPRECATED - Added for backwards compatibility with previous charts
  extraEnv: {}
  pod:
    labels: {}
    annotations: {}
  deployment:
    annotations: {}
    labels: {}
  statefulset:
    annotations: {}
    labels: {}
  service:
    labels: {}
    annotations: {}

replicaCount: 1

# The default image to be used for containers in the deployment, can be overridden per container
image:
  repository: nginx
  # This sets the pull policy for images.
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""
deploymentPostfix: ""

env: {}
envTpls: []
envFrom: {}

# DEPRECATED - Added for backwards compatibility with previous charts
extraEnv: {}

addReloaderAnnotations: true

serviceAccount:
  create: true
  automount: true
  annotations: {}
  name: ""

role:
  create: false
  type: "Role"  # Role or ClusterRole
  rules: []

podAnnotations: {}
podAnnotationsTpls: []
podLabels: {}

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 999
  runAsGroup: 0
  fsGroup: 0
  fsGroupChangePolicy: "OnRootMismatch"
  seccompProfile:
    type: "RuntimeDefault"

# if no securityContext is defined at the container level, this will be used
securityContext:
  capabilities:
    add: []
    drop: []
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: false
  privileged: false

# https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#lifecycle
# default value is 30s
terminationGracePeriodSeconds:

topologySpreadConstraints:
  - maxSkew: 1
    topologyKey: zone
    whenUnsatisfiable: ScheduleAnyway
  - maxSkew: 1
    topologyKey: hostname
    whenUnsatisfiable: ScheduleAnyway

initContainers: {}

containers: {}
#  nginx:
#    command: []
#    args: []
#    env: {}
#    envFrom: {}
#    securityContext: {}
#    image: {}
#    ports:
#      - containerPort: 80
#        name: http
#    livenessProbe:
#      httpGet:
#        path: /
#        port: http
#    readinessProbe:
#      httpGet:
#        path: /
#        port: http
#    startupProbe:
#      httpGet:
#        path: /
#        port: http
#    lifecycle: {}
#    resources:
#      limits:
#        cpu: 100m
#        memory: 128Mi
#      requests:
#        cpu: 100m
#        memory: 128Mi
#    volumeMounts: []
#    volumeMountsTpls: []

jobs: {}
#  example:
#    ttlSecondsAfterFinished: 100
#    annotations:
#      "helm.sh/hook": post-install
#    containers:
#      nginx:
#        command: [ ]
#        args: [ ]
#        env: { }
#        envFrom: { }
#        securityContext: { }
#        image: { }
#        ports:
#          - containerPort: 80
#            name: http
#        livenessProbe:
#          httpGet:
#            path: /
#            port: http
#        readinessProbe:
#          httpGet:
#            path: /
#            port: http
#        startupProbe:
#          httpGet:
#            path: /
#            port: http
#        lifecycle: { }
#        resources:
#          limits:
#            cpu: 100m
#            memory: 128Mi
#          requests:
#            cpu: 100m
#            memory: 128Mi
#        volumeMounts: []
#        volumeMountsTpls: []

cronJobs: {}
#  example:
#    schedule: "*/5 * * * *"
#    annotations: { }
#    containers:
#      nginx:
#        command: [ ]
#        args: [ ]
#        env: { }
#        envFrom: { }
#        securityContext: { }
#        image: { }
#        ports:
#          - containerPort: 80
#            name: http
#        livenessProbe:
#          httpGet:
#            path: /
#            port: http
#        readinessProbe:
#          httpGet:
#            path: /
#            port: http
#        startupProbe:
#          httpGet:
#            path: /
#            port: http
#        lifecycle: { }
#        resources:
#          limits:
#            cpu: 100m
#            memory: 128Mi
#          requests:
#            cpu: 100m
#            memory: 128Mi
#        volumeMounts: []
#        volumeMountsTpls: []

# This is for setting up a service more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  enabled: true
  labels: {}
  annotations: {}
  # This path is currently only used for AWS ALB health checks
  loadBalancerHealthCheckPath: ""
  # This sets the service type more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  type: ClusterIP
  ports:
    - port: 80
      targetPort: http
      protocol: TCP
      name: http

# This block is for setting up the ingress for more information can be found here: https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  enabled: false
  className: ""
  annotations:
    {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

# This section is for setting up autoscaling more information can be found here: https://kubernetes.io/docs/concepts/workloads/autoscaling/
# Values defined here will override the values defined in the sizing section.
autoscaling:
  horizontal: {}
#    enabled: false
#    minReplicas: 1
#    maxReplicas: 5
#    targetCPUUtilizationPercentage: 80
#    targetMemoryUtilizationPercentage: 80
  vertical: {}
#    enabled: false
#    updateMode: "Auto"
#    containerPolicies:
#      - containerName: "*"
#        controlledResources:
#          - memory
#          - cpu

# This section is for setting up a Pod Disruption Budget (PDB) more information can be found here: https://kubernetes.io/docs/tasks/run-application/configure-pdb/
podDisruptionBudget:
  enabled: true
  # Only one of maxUnavailable and minAvailable can be specified
  maxUnavailable: 1
  # minAvailable: 1
  annotations: {}

# Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

volumesTpls: []

nodeSelector: {}

tolerations: []

affinity: {}

test:
  enabled: false

size: ""

# Configure scale dependant variables.  This enables configuring "t-shirt" sizes for different deployments.
# This is useful for setting up different resource requests and limits for different environments.
# Resources - https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
# Env - Follows the same format rules for `env` and `containers.env` values
# autoscaling - https://kubernetes.io/docs/concepts/workloads/autoscaling/
sizing:
  default:
    resources: {}
    env: {}
    autoscaling:
      horizontal:
        enabled: false
        minReplicas: 1
        maxReplicas: 5
        targetCPUUtilizationPercentage: 80
        targetMemoryUtilizationPercentage: 80
      vertical:
        enabled: false
        updateMode: "Auto"
        containerPolicies:
          - containerName: "*"
            controlledResources:
              - memory
              - cpu
  testing:
    resources:
      requests:
        cpu: "100m"
        memory: 128Mi
    autoscaling:
      horizontal:
        enabled: false
#  small:
#    resources:
#      requests:
#        cpu: 100m
#        memory: 128Mi
#        ephemeral-storage: "2Gi"
#      limits:
#        cpu: 100m
#        memory: 128Mi
#        ephemeral-storage: "2Gi"
#    env:
#      - name: GORILLA_TSHIRT_SIZE
#        value: small
#    autoscaling:
#      horizontal:
#        minReplicas: 1
#        maxReplicas: 5
#        targetCPUUtilizationPercentage: 80
#        targetMemoryUtilizationPercentage: 80

# DEPRECATED - All below values added for backwards compatibility with previous charts
pod:
  labels: {}
  annotations: {}
  securityContext: {}

container:
  securityContext: {}

deployment:
  labels: {}
  annotations: {}

statefulset:
  labels: {}
  annotations: {}

resources: {}
#  requests:
#    cpu: 500m
#    memory: 1Gi
#  limits:
#    cpu: 4000m
#    memory: 8Gi
