# Default values for wandb-base.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

kind: Deployment

global: {}

replicaCount: 1

# The default image to be used for containers in the deployment, can be overridden per container
image:
  repository: nginx
  # This sets the pull policy for images.
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

env: {}
envFrom: {}

addReloaderAnnotations: true

serviceAccount:
  create: true
  automount: true
  annotations: {}
  name: ""

role:
  create: false
  rules: []

podAnnotations: {}
podLabels: {}

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 999
  runAsGroup: 0
  fsGroup: 0
  fsGroupChangePolicy: "OnRootMismatch"
  seccompProfile:
    type: "RuntimeDefault"

securityContext:
  capabilities:
    add: []
    drop: []
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: false
  privileged: false

initContainers: {}

containers: {}
#  nginx:
#    command: []
#    args: []
#    env: {}
#    envFrom: {}
#    securityContext: {}
#    image: {}
#    ports:
#      - containerPort: 80
#        name: http
#    livenessProbe:
#      httpGet:
#        path: /
#        port: http
#    readinessProbe:
#      httpGet:
#        path: /
#        port: http
#    startupProbe:
#      httpGet:
#        path: /
#        port: http
#    lifecycle: {}
#    resources:
#      limits:
#        cpu: 100m
#        memory: 128Mi
#      requests:
#        cpu: 100m
#        memory: 128Mi
#    volumeMounts: []

jobs: {}
#  example:
#    ttlSecondsAfterFinished: 100
#    annotations:
#      "helm.sh/hook": post-install
#    containers:
#      nginx:
#        command: [ ]
#        args: [ ]
#        env: { }
#        envFrom: { }
#        securityContext: { }
#        image: { }
#        ports:
#          - containerPort: 80
#            name: http
#        livenessProbe:
#          httpGet:
#            path: /
#            port: http
#        readinessProbe:
#          httpGet:
#            path: /
#            port: http
#        startupProbe:
#          httpGet:
#            path: /
#            port: http
#        lifecycle: { }
#        resources:
#          limits:
#            cpu: 100m
#            memory: 128Mi
#          requests:
#            cpu: 100m
#            memory: 128Mi
#        volumeMounts: [ ]

cronJobs: {}
#  example:
#    schedule: "*/5 * * * *"
#    annotations: { }
#    containers:
#      nginx:
#        command: [ ]
#        args: [ ]
#        env: { }
#        envFrom: { }
#        securityContext: { }
#        image: { }
#        ports:
#          - containerPort: 80
#            name: http
#        livenessProbe:
#          httpGet:
#            path: /
#            port: http
#        readinessProbe:
#          httpGet:
#            path: /
#            port: http
#        startupProbe:
#          httpGet:
#            path: /
#            port: http
#        lifecycle: { }
#        resources:
#          limits:
#            cpu: 100m
#            memory: 128Mi
#          requests:
#            cpu: 100m
#            memory: 128Mi
#        volumeMounts: [ ]

# This is for setting up a service more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  enabled: true
  # This path is currently only used for AWS ALB health checks
  loadBalancerHealthCheckPath: ""
  # This sets the service type more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  type: ClusterIP
  ports:
    - port: 80
      targetPort: http
      protocol: TCP
      name: http

# This block is for setting up the ingress for more information can be found here: https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  enabled: false
  className: ""
  annotations:
    {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

# This section is for setting up autoscaling more information can be found here: https://kubernetes.io/docs/concepts/workloads/autoscaling/
# Values defined here will override the values defined in the sizing section.
autoscaling: {}
#   horizontal:
#     enabled: false
#     minReplicas: 1
#     maxReplicas: 5
#     targetCPUUtilizationPercentage: 80
#     targetMemoryUtilizationPercentage: 80
#   vertical:
#     enabled: false
#     updateMode: "Auto"
#     containerPolicies:
#       - containerName: "*"
#         controlledResources:
#           - memory
#           - cpu

# Additional volumes on the output Deployment definition.
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

nodeSelector: {}

tolerations: []

affinity: {}

test:
  enabled: false

size: ""

# Configure scale dependant variables.  This enables configuring "t-shirt" sizes for different deployments.
# This is useful for setting up different resource requests and limits for different environments.
# Resources - https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
# Env - Follows the same format rules for `env` and `containers.env` values
# autoscaling - https://kubernetes.io/docs/concepts/workloads/autoscaling/
sizing:
  default:
    resources: {}
    env: {}
    autoscaling:
      horizontal:
        enabled: false
        minReplicas: 1
        maxReplicas: 5
        targetCPUUtilizationPercentage: 80
        targetMemoryUtilizationPercentage: 80
      vertical:
        enabled: false
        updateMode: "Auto"
        containerPolicies:
          - containerName: "*"
            controlledResources:
              - memory
              - cpu
#  small:
#    resources:
#      requests:
#        cpu: 100m
#        memory: 128Mi
#        ephemeral-storage: "2Gi"
#      limits:
#        cpu: 100m
#        memory: 128Mi
#        ephemeral-storage: "2Gi"
#    env:
#      - name: GORILLA_TSHIRT_SIZE
#        value: small
#    autoscaling:
#      horizontal:
#        minReplicas: 1
#        maxReplicas: 5
#        targetCPUUtilizationPercentage: 80
#        targetMemoryUtilizationPercentage: 80
