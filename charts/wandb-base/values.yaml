# Default values for wandb-base.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

kind: Deployment

global:
  cloudProvider: ""  # cloud provider, e.g. aws, gcp, azure
  env: {}
  imagePullSecrets: []
  # DEPRECATED - Added for backwards compatibility with previous charts
  extraEnv: {}
  # Common labels and annotations applied to all resources
  common:
    labels: {}
    annotations: {}
  pod:
    labels: {}
    annotations: {}
  deployment:
    annotations: {}
    labels: {}
  statefulset:
    annotations: {}
    labels: {}
  service:
    labels: {}
    annotations: {}

replicaCount: 1

# The default image to be used for containers in the deployment, can be overridden per container
image:
  repository: nginx
  # This sets the pull policy for images.
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""
deploymentPostfix: ""

helmHook:
  enabled: false
  hook: ""
  hookWeight: "0"
  hookDeletePolicy: "before-hook-creation,hook-succeeded"

env: {}
envTpls: []
envFrom: {}

# DEPRECATED - Added for backwards compatibility with previous charts
extraEnv: {}

addReloaderAnnotations: true

# Common labels and annotations applied to all resources (local to this chart)
common:
  labels: {}
  annotations: {}

serviceAccount:
  create: true
  automount: true
  annotations: {}
  name: ""

role:
  create: false
  type: "Role"  # Role or ClusterRole
  rules: []

podAnnotations: {}
podAnnotationsTpls: []
podLabels: {}

podSecurityContext:
  runAsNonRoot: true
  runAsUser: 999
  runAsGroup: 0
  fsGroup: 0
  fsGroupChangePolicy: "OnRootMismatch"
  seccompProfile:
    type: "RuntimeDefault"

# if no securityContext is defined at the container level, this will be used
securityContext:
  capabilities:
    add: []
    drop: []
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: false
  privileged: false

strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 1
    maxUnavailable: 0

# https://kubernetes.io/docs/reference/kubernetes-api/workload-resources/pod-v1/#lifecycle
terminationGracePeriodSeconds: 60

topologySpreadConstraints:
  - maxSkew: 1
    topologyKey: topology.kubernetes.io/zone
    whenUnsatisfiable: ScheduleAnyway
  - maxSkew: 1
    topologyKey: kubernetes.io/hostname
    whenUnsatisfiable: ScheduleAnyway

initContainers: {}

containers: {}
# Example container configuration:
#  nginx:
#    command: ["nginx"]
#    args: ["-g", "daemon off;"]
#    env:
#      NGINX_HOST: "example.com"
#      NGINX_PORT: "80"
#    envFrom:
#      nginx-config: "configMapRef"
#      nginx-secrets: "secretRef"
#    securityContext:
#      allowPrivilegeEscalation: false
#      readOnlyRootFilesystem: true
#    image:
#      repository: nginx
#      tag: "1.21.6"
#      pullPolicy: IfNotPresent
#    ports:
#      - containerPort: 80
#        name: http
#      - containerPort: 443
#        name: https
#    livenessProbe:
#      httpGet:
#        path: /healthz
#        port: http
#      initialDelaySeconds: 30
#      periodSeconds: 10
#      timeoutSeconds: 5
#      successThreshold: 1
#      failureThreshold: 3
#    readinessProbe:
#      httpGet:
#        path: /ready
#        port: http
#      initialDelaySeconds: 5
#      periodSeconds: 10
#      timeoutSeconds: 5
#      successThreshold: 1
#      failureThreshold: 3
#    startupProbe:
#      httpGet:
#        path: /startup
#        port: http
#      initialDelaySeconds: 10
#      periodSeconds: 5
#      timeoutSeconds: 5
#      successThreshold: 1
#      failureThreshold: 30
#    lifecycle:
#      preStop:
#        exec:
#          command: ["/usr/sbin/nginx", "-s", "quit"]
#    resources:
#      limits:
#        cpu: 200m
#        memory: 256Mi
#      requests:
#        cpu: 100m
#        memory: 128Mi
#    volumeMounts:
#      - name: nginx-config
#        mountPath: /etc/nginx/conf.d
#      - name: nginx-cache
#        mountPath: /var/cache/nginx
#    volumeMountsTpls: []

jobs: {}
# Example job configuration:
#  database-migration:
#    ttlSecondsAfterFinished: 3600
#    annotations:
#      "helm.sh/hook": post-install,post-upgrade
#      "helm.sh/hook-weight": "0"
#      "helm.sh/hook-delete-policy": hook-succeeded
#    containers:
#      migration:
#        command: ["./migrate.sh"]
#        args: ["--database", "$(DATABASE_NAME)", "--user", "$(DATABASE_USER)"]
#        env:
#          DATABASE_NAME: "example_db"
#          DATABASE_USER: "db_user"
#          LOG_LEVEL: "info"
#        envFrom:
#          db-credentials: "secretRef"
#          app-config: "configMapRef"
#        securityContext:
#          allowPrivilegeEscalation: false
#          readOnlyRootFilesystem: true
#        image:
#          repository: example/migration
#          tag: "v1.2.3"
#          pullPolicy: IfNotPresent
#        resources:
#          limits:
#            cpu: 500m
#            memory: 512Mi
#          requests:
#            cpu: 200m
#            memory: 256Mi
#        volumeMounts:
#          - name: migration-scripts
#            mountPath: /app/migrations
#          - name: temp-data
#            mountPath: /tmp
#        volumeMountsTpls: []

cronJobs: {}
# Example cronjob configuration:
#  cleanup-data:
#    schedule: "0 2 * * *"  # Run at 2 AM every day
#    concurrencyPolicy: "Forbid"
#    failedJobsHistoryLimit: 3
#    successfulJobsHistoryLimit: 5
#    startingDeadlineSeconds: 300
#    annotations:
#      "app.kubernetes.io/part-of": "data-management"
#      "monitoring.example.com/alert": "true"
#    containers:
#      cleaner:
#        command: ["/bin/sh"]
#        args: ["-c", "/app/cleanup.sh --older-than 30d --dry-run=false"]
#        env:
#          MAX_DELETION_BATCH: "1000"
#          BACKUP_ENABLED: "true"
#          LOG_LEVEL: "info"
#        envFrom:
#          storage-credentials: "secretRef"
#          app-config: "configMapRef"
#        securityContext:
#          allowPrivilegeEscalation: false
#          readOnlyRootFilesystem: true
#        image:
#          repository: example/data-cleaner
#          tag: "v2.1.0"
#          pullPolicy: IfNotPresent
#        resources:
#          limits:
#            cpu: 500m
#            memory: 512Mi
#          requests:
#            cpu: 200m
#            memory: 256Mi
#        volumeMounts:
#          - name: cleanup-scripts
#            mountPath: /app
#            readOnly: true
#          - name: backup-data
#            mountPath: /backups
#        volumeMountsTpls: []

# This is for setting up a service more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  enabled: false
  labels: {}
  annotations: {}
  # Additional configuration for cloud provider load balancers, make sure to set the cloud provider in the global section.
  loadBalancer:
    # Enabling this adds annotations for cloud provider specific load balancers.
    enabled: true
    timeoutSec: 120
    connectionDraining:
      drainingTimeoutSec: 60
    healthCheck:
      path: ""
      checkIntervalSec: 1
      timeoutSec: 1
      healthyThreshold: 1
      unhealthyThreshold: 3
  # This sets the service type more information can be found here: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services-service-types
  type: ClusterIP
  ports:
    - port: 80
      targetPort: http
      protocol: TCP
      name: http

# This block is for setting up the ingress for more information can be found here: https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  enabled: false
  className: ""
  annotations:
    {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

# This section is for setting up autoscaling more information can be found here: https://kubernetes.io/docs/concepts/workloads/autoscaling/
# Values defined here will override the values defined in the sizing section.
autoscaling:
  horizontal: {}
#    enabled: false
#    minReplicas: 1
#    maxReplicas: 5
#    targetCPUUtilizationPercentage: 80
#    targetMemoryUtilizationPercentage: 80
  vertical: {}
#    enabled: false
#    updateMode: "Auto"
#    containerPolicies:
#      - containerName: "*"
#        controlledResources:
#          - memory
#          - cpu

# This section is for setting up a Pod Disruption Budget (PDB) more information can be found here: https://kubernetes.io/docs/tasks/run-application/configure-pdb/
podDisruptionBudget:
  enabled: true
  # Only one of maxUnavailable and minAvailable can be specified
  maxUnavailable: 1
  # minAvailable: 1
  annotations: {}

# Additional volumes on the output Deployment definition.
volumes: []
# Example volume configurations:
# - name: config-volume
#   configMap:
#     name: app-config
#     optional: false
#     items:
#       - key: config.json
#         path: config/config.json
# - name: secret-volume
#   secret:
#     secretName: app-secrets
#     optional: false
#     defaultMode: 0400
# - name: data-volume
#   persistentVolumeClaim:
#     claimName: app-data-pvc
# - name: temp-volume
#   emptyDir:
#     medium: Memory
#     sizeLimit: 256Mi
# - name: shared-volume
#   hostPath:
#     path: /var/shared
#     type: DirectoryOrCreate

volumesTpls: []

nodeSelector: {}

tolerations: []

affinity: {}

test:
  enabled: false

size: ""

# Configure scale-dependent variables.  This enables configuring "t-shirt" sizes for different deployments.
# This is useful for setting up different resource requests and limits for different environments.
# Resources - https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
# Env - Follows the same format rules for `env` and `containers.env` values
# autoscaling - https://kubernetes.io/docs/concepts/workloads/autoscaling/
sizing:
  default:
    replicaCount: 1
    resources: {}
    env: {}
    autoscaling:
      horizontal:
        enabled: false
        minReplicas: 1
        maxReplicas: 5
        targetCPUUtilizationPercentage: 80
        targetMemoryUtilizationPercentage: 80
      vertical:
        enabled: false
        updateMode: "Auto"
        containerPolicies:
          - containerName: "*"
            controlledResources:
              - memory
              - cpu
  testing:
    resources:
      requests:
        cpu: "100m"
        memory: 128Mi
    autoscaling:
      horizontal:
        enabled: false
#  small:
#    resources:
#      requests:
#        cpu: 100m
#        memory: 128Mi
#        ephemeral-storage: "2Gi"
#      limits:
#        cpu: 100m
#        memory: 128Mi
#        ephemeral-storage: "2Gi"
#    env:
#      GORILLA_TSHIRT_SIZE: "small"
#      MAX_CONNECTIONS: "100"
#      CACHE_SIZE: "64Mi"
#      LOG_LEVEL: "info"
#    autoscaling:
#      horizontal:
#        enabled: true
#        minReplicas: 1
#        maxReplicas: 5
#        targetCPUUtilizationPercentage: 80
#        targetMemoryUtilizationPercentage: 80
#      vertical:
#        enabled: false
#        updateMode: "Auto"
#        containerPolicies:
#          - containerName: "*"
#            controlledResources:
#              - memory
#              - cpu

# DEPRECATED - All below values added for backwards compatibility with previous charts
pod:
  labels: {}
  annotations: {}
  securityContext: {}

container:
  securityContext: {}

deployment:
  labels: {}
  annotations: {}

statefulset:
  labels: {}
  annotations: {}

resources: {}
# Example resources configuration:
#  requests:
#    cpu: 500m
#    memory: 1Gi
#    ephemeral-storage: "5Gi"
#  limits:
#    cpu: 4000m
#    memory: 8Gi
#    ephemeral-storage: "10Gi"
