## NOTICE
#
# Due to the scope and complexity of this chart, all possible values are not
# documented in this file. Extensive documentation is available.
#
# Because properties are regularly added, updated, or relocated, it is _strongly
# suggest_ to not "copy and paste" this YAML. Please provide Helm only those
# properties you need, and allow the defaults to be provided by the version of
# this chart at the time of deployment.

# The global properties are used to configure multiple charts at once.
global:
  # This should be the fqdn of where your users will be accessing the instance.
  host: "http://localhost:8080"
  license: ""

  licenseSecret:
    name: ""
    key: ""
  # List of image pull secrets for accessing private container registries.
  # Example:
  # imagePullSecrets: &imagePullSecrets
  #   - my-registry-secret
  imagePullSecrets: &imagePullSecrets []

  cloudProvider: ""

  storageClass: ""

  banners:
    {}
    # banner1:
    #   type: warning | error | info
    #   message: "This is a warning message"
    #   heading: "This is a warning"
    #   dismissable: true
    # banner2:
    #   type: warning | error | info
    #   message: "This is a warning message"
    #   heading: "This is a warning"

  common:
    labels: {}
    annotations: {}

  ## Supplemental Pod labels. Will not be used for selectors.
  pod:
    labels: {}
    annotations: {}
  deployment:
    annotations:
      reloader.stakater.com/auto: "true"
    labels: {}
  daemonset:
    annotations:
      reloader.stakater.com/auto: "true"
    labels: {}
  statefulset:
    annotations:
      reloader.stakater.com/auto: "true"
    labels: {}
  service:
    labels: {}
    annotations: {}

  extraEnvFrom: {}
  extraEnv: {}

  operator:
    namespace: default

  mysql:
    host: ""
    port: 3306
    database: "wandb_local"
    user: "wandb"
    password: ""
    passwordSecret:
      name: ""
      rootPasswordKey: "MYSQL_ROOT_PASSWORD"
      passwordKey: "MYSQL_PASSWORD"

  slack:
    secret: ""
    clientId: ""

  otel:
    traces:
      # defaults to the otel-daemonset service
      host: ""
      # grpc default is 4317, http default is 4318
      port: 4317
      # grpc, http
      proto: "grpc"

  clickhouse:
    host: "{{ .Release.Name }}-clickhouse-headless"
    port: ""
    password: ""
    passwordSecret:
      name: ""
      passwordKey: "CLICKHOUSE_PASSWORD"
    database: "weave_trace_db"
    user: "default"
    # Required when using replicated services on self-managed ClickHouse (not ClickHouse Cloud).
    # Flag will substitute MergeTree() with ReplicatedMergeTree() and use `ON CLUSTER` on table creation.
    replicated: false

  email:
    smtp:
      host: ""
      port: 587
      user: ""
      password: ""

  auth:
    sessionLengthHours: 720
    # Internal URL for the auth service should be using oidc or auth0
    jwkUrl: ""
    oidc:
      clientId: ""
      secret: ""
      authMethod: ""
      issuer: ""

  # Storage bucket that will be used by the application by default but can be overridden by the user in the wandb-console.
  defaultBucket:
    # az, s3, gcs
    provider: "s3"
    name: ""
    path: ""
    region: ""
    kmsKey: ""

  # If specified the application will use this bucket for all storage operations, and will not be overridable by the user.
  bucket:
    secret:
      secretName: ""
      accessKeyName: "ACCESS_KEY"
      secretKeyName: "SECRET_KEY"

  redis:
    host: ""
    port: 6379
    password: ""
    # external should remain false; it is for W&B internal use only.
    external: false
    parameters: {}
    params: {}
    caCert: ""
    secret:
      secretName: ""
      secretKey: "REDIS_PASSWORD"

  bigtable:
    v3:
      enabled: false
    v2:
      enabled: false
    # host is only used when running against the bigtable emulator
    host: ""
    project: ""
    instance: ""

  pubSub:
    enabled: false
    # host is only used when running against the pubsub emulator
    host: ""
    project: ""
    filestreamTopic: ""
    runUpdateShadowTopic: ""

  kafka:
    # The following values are anchored here, and referenced by alias later for
    # the kafka dependency chart.
    user: &kafkaUser "wandb"
    password: &kafkaPassword "wandb"
    ## The secret can be created using the following command:
    ## "kubectl create secret generic SECRET_NAME --from-literal=client-passwords=CLIENT_PASSWORD1 --from-literal=inter-broker-password=INTER_BROKER_PASSWORD --from-literal=controller-password=CONTROLLER_PASSWORD"
    ## Replace SECRET_NAME, CLIENT_PASSWORD1, INTER_BROKER_PASSWORD, and CONTROLLER_PASSWORD with appropriate values.
    passwordSecret:
      name: &kafkaSecretName ""
      # This (client-passwords) should match the key name used in the secret
      passwordKey: "client-passwords"
    brokerHost: ""
    brokerPort: 9092
    runUpdatesShadowTopic: ""
    # This value will only apply upon initial topic creation.
    # If the topic already exists, then changing the number of partitions is not possible.
    runUpdatesShadowNumPartitions: 12

  # To provide custom CA certificates, you can use either:
  # 1. `customCACerts`: a list of certificates provided directly within this Helm chart.
  # 2. `configMapName`: the name of a ConfigMap containing CA certificates.
  #
  # Important:
  # - If using a ConfigMap, each key in the ConfigMap must end with `.crt` (e.g., `my-cert.crt`).
  # - This naming convention is required for `update-ca-certificates` to parse and add each
  #   certificate to the system CA store on Ubuntu-based systems.

  # List of custom CA certificates in PEM format.
  customCACerts: []
  # Name of a ConfigMap containing additional .crt files for CA certificates.
  caCertsConfigMap: ""

  weave-trace:
    enabled: false

  api:
    enabled: false
    additionalPaths:
      proxy: false
      files: false
      debug: false
      service_redirect: false
      service_dangerzone: false
      artifacts: false
      oidc: false
      analytics: false
      scim: false
      admin: false

  glue:
    enabled: false

  beta:
    bufstream:
      enabled: false

  executor:
    enabled: false

  settingsMigrationJob:
    debug: false
    dryRun: true

  # GCP only value: a CloudArmor policy to be attached to the gce LoadBalancer via a BackendConfig.
  # https://cloud.google.com/kubernetes-engine/docs/how-to/ingress-configuration#cloud_armor
  gcpSecurityPolicy: ""

  statsig:
    apiKey: ""

ingress:
  install: true
  create: true
  nameOverride: ""
  defaultBackend: "app"
  annotations: {}
  labels: {}
  tls: []
  additionalHosts: []
  class: ""
  issuer:
    create: false
    provider: ""
    server: https://acme-v02.api.letsencrypt.org/directory
    email: support@wandb.com
  secondary:
    create: false
    install: true
    nameOverride: ""
    defaultBackend: "app"
    annotations: {}
    labels: {}
    tls: []
    additionalHosts: []
    class: ""
    issuer:
      create: false
      provider: ""
      server: https://acme-v02.api.letsencrypt.org/directory
      email: support@wandb.com

artifactsGc:
  BatchSize: 0
  NumWorkers: 0
  DeleteFilesNumWorkers: 0

parquet:
  install: true
  deploymentPostfix: "bc"
  image:
    repository: wandb/megabinary
    tag: latest
  fuse:
    enabled: false
    resources:
      requests:
        cpu: 1
        memory: 1Gi
      limits:
        cpu: 2
        memory: 2Gi
        ephemeral-storage: 10Gi
    fileCacheCapacity: 9.5Gi
  envFrom:
    "{{ .Release.Name }}-bucket-configmap": "configMapRef"
    "{{ .Release.Name }}-mysql-configmap": "configMapRef"
    "{{ .Release.Name }}-redis-configmap": "configMapRef"
    "{{ .Release.Name }}-kafka-configmap": "configMapRef"
    "{{ .Release.Name }}-global-secret": "secretRef"
    "{{ .Release.Name }}-parquet-configmap": "configMapRef"
    "{{ .Release.Name }}-parquet-secret": "secretRef"
  envTpls:
    - '{{ include "wandb.downwardEnvs" . }}'
    - '{{ include "wandb.bucketEnvs" . }}'
    - '{{ include "wandb.mysqlEnvs" . }}'
    - '{{ include "wandb.redisEnvs" . }}'
    - '{{ include "wandb.queueEnvs" . }}'
    - '{{ include "wandb.historyStoreEnvs" . }}'
  podAnnotationsTpl:
    - '{{ include "wandb.gksFuseAnnotations" . }}'
  containers:
    parquet:
      args: ["parquet"]

app:
  install: true
  deploymentPostfix: "bc"
  image:
    repository: wandb/local
    tag: latest
  env:
#    GORILLA_AUTH_JWK_URL: "http://localhost:8083/api/jwks.json"
    GORILLA_LICENSE_CERT_PATH: "/var/app/jwks.json"
    GORILLA_GLUE_VIEW_SPEC_UPDATER_EXECUTABLE: "/usr/local/bin/view-spec-updater-linux"
    BUCKET_QUEUE: internal://
    GORILLA_TASK_CONFIG_PATH: "/etc/service/gorilla-glue/glue_tasks_local.yaml"
    GORILLA_VIEW_SPEC_UPDATER_EXECUTABLE: "/usr/local/bin/view-spec-updater-linux"
  envFrom:
    "{{ .Release.Name }}-bucket-configmap": "configMapRef"
    "{{ .Release.Name }}-mysql-configmap": "configMapRef"
    "{{ .Release.Name }}-redis-configmap": "configMapRef"
    "{{ .Release.Name }}-kafka-configmap": "configMapRef"
    "{{ .Release.Name }}-global-secret": "secretRef"
    "{{ .Release.Name }}-api-secret": "secretRef"
    "{{ .Release.Name }}-api-configmap": "configMapRef"
    "{{ .Release.Name }}-glue-secret": "secretRef"
    "{{ .Release.Name }}-glue-configmap": "configMapRef"
    "{{ .Release.Name }}-gorilla-session-key": "secretRef"
    "{{ .Release.Name }}-frontend-configmap": "configMapRef"
    "{{ .Release.Name }}-app-configmap": "configMapRef"
    "{{ .Release.Name }}-app-secret": "secretRef"
  envTpls:
    - '{{ include "wandb.downwardEnvs" . }}'
    - '{{ include "wandb.bucketEnvs" . }}'
    - '{{ include "wandb.mysqlEnvs" . }}'
    - '{{ include "wandb.redisEnvs" . }}'
    - '{{ include "wandb.queueEnvs" . }}'
    - '{{ include "wandb.historyStoreEnvs" . }}'
  service:
    ports:
      - port: 8080
        protocol: TCP
        name: app
      - port: 8181
        protocol: TCP
        name: prometheus
      - port: 8082
        protocol: TCP
        name: anaconda
      - port: 8083
        protocol: TCP
        name: local
  initContainers:
    init-db:
      command: ['bash', '-c', "until mysql -h$MYSQL_HOST -u$MYSQL_USER -p$MYSQL_PASSWORD -D$MYSQL_DATABASE -P$MYSQL_PORT --execute=\"SELECT 1\"; do echo waiting for db; sleep 2; done"]
  containers:
    app:
      ports:
        - name: http
          containerPort: 8080
          protocol: TCP
        - name: prometheus
          containerPort: 8181
          protocol: TCP
        - name: anaconda
          containerPort: 8082
          protocol: TCP
        - name: local
          containerPort: 8083
          protocol: TCP
        - name: gorilla-statsd
          containerPort: 8125
          protocol: TCP
      livenessProbe:
        httpGet:
          path: /healthz
          port: http
      readinessProbe:
        httpGet:
          path: /ready
          port: http
        initialDelaySeconds: 20
        periodSeconds: 5
      startupProbe:
        httpGet:
          path: /ready
          port: http
        initialDelaySeconds: 20
        periodSeconds: 5
        failureThreshold: 120
      lifecycle:
        preStop:
          exec:
            command: ["sleep", "25"]
      volumeMountsTpls:
        - '{{ include "wandb.caCertsVolumeMounts" . }}'
  role:
    create: true
    rules:
      - apiGroups: [""]
        resources: ["secrets"]
        verbs: ["get", "create", "update", "delete"]
      - apiGroups: [""]
        resources: ["namespaces"]
        verbs: ["get"]
  volumesTpls:
    - '{{ include "wandb.caCertsVolumes" . }}'

nginx:
  install: false

weave:
  install: true
  deploymentPostfix: "bc"
  cache:
    intervalInHours: 24
    size: 20Gi
    medium: ""
  image:
    repository: wandb/local
    tag: latest
  service:
    ports:
      - port: 9994
        protocol: TCP
        name: weave
  envFrom:
    "{{ .Release.Name }}-weave-configmap": "configMapRef"
  containers:
    weave:
      ports:
        - name: http
          containerPort: 9994
          protocol: TCP
      livenessProbe:
        httpGet:
          path: /__weave/hello
          port: http
      readinessProbe:
        httpGet:
          path: /__weave/hello
          port: http
      startupProbe:
        httpGet:
          path: /__weave/hello
          port: http
        failureThreshold: 12
        periodSeconds: 10
      volumeMounts:
        - name: cache
          mountPath: /vol/weave/cache
    weave-cache-clear:
      command:
        - /bin/bash
        - -c
        - |
          if [ -f /var/app/weave-python/venv/bin/activate ]; then
            source /var/app/weave-python/venv/bin/activate
          fi
          python -m weave.clear_cache
      resources:
        requests:
          cpu: 100m
          memory: 128Mi
      volumeMounts:
        - name: cache
          mountPath: /vol/weave/cache
  env:
    ONLY_SERVICE: weave
  volumes:
    - name: cache
      emptyDir:
        sizeLimit: '{{ .Values.cache.size }}'
        medium: '{{ .Values.cache.medium }}'

weave-trace:
  install: false
  deploymentPostfix: "bc"
  image:
    repository: wandb/weave-trace
    tag: latest
  datadog:
    enabled: false
  envFrom:
    "{{ .Release.Name }}-global-secret": "secretRef"
    "{{ .Release.Name }}-weave-trace-configmap": "configMapRef"
    "{{ .Release.Name }}-clickhouse-configmap": "configMapRef"
  env:
    WF_CLICKHOUSE_PASS:
      valueFrom:
        secretKeyRef:
          name: '{{ include "wandb.clickhouse.passwordSecret" . }}'
          key: '{{ .Values.global.clickhouse.passwordSecret.passwordKey }}'
  initContainers:
    weave-trace-migrate:
      command: ["python", "migrator.py"]
  containers:
    weave-trace:
      ports:
        - name: http
          containerPort: 8080
          protocol: TCP
  service:
    ports:
      - name: http
        port: 8722
        protocol: TCP

console:
  install: true
  deploymentPostfix: "bc"
  service:
    enabled: true
    type: ClusterIP
    ports:
    - port: 8082
      protocol: TCP
      name: console
  image:
    repository: wandb/console
    tag: latest
  envFrom:
    "{{ .Release.Name }}-console-configmap": "configMapRef"
  proxy:
    httpProxy: ""
    httpsProxy: ""
    noProxy: ""
    debug: false
  containers:
    console:
      ports:
        - name: http
          containerPort: 8082
          protocol: TCP
      livenessProbe:
        httpGet:
          path: /console/api/healthz
          port: http
      readinessProbe:
        httpGet:
          path: /console/api/ready
          port: http
        initialDelaySeconds: 20
        periodSeconds: 5
      startupProbe:
        httpGet:
          path: /console/api/ready
          port: http
        initialDelaySeconds: 20
        periodSeconds: 5
        failureThreshold: 120
  role:
    create: true
    type: ClusterRole
    rules:
      - apiGroups: [""]
        resources: ["secrets"]
        verbs: ["get", "list", "watch", "patch", "create"]
      - apiGroups: [""]
        resources: ["namespaces", "pods", "pods/log", "configmaps", "services", "serviceaccounts", "events"]
        verbs: ["get", "list"]
      - apiGroups: ["apps"]
        resources: ["deployments", "statefulsets", "daemonsets", "replicasets", "controllerrevisions"]
        verbs: ["get", "list"]
      - apiGroups: ["apps"]
        resources: ["deployments/status", "statefulsets/status", "daemonsets/status", "replicasets/status"]
        verbs: ["get"]
      - apiGroups: ["apps.wandb.com"]
        resources: ["weightsandbiases"]
        verbs: ["get"]

flat-run-fields-updater:
  install: false
  deploymentPostfix: "bc"
  pubsub:
    subscriptions: ""
  service:
    enabled: false
  autoscaling:
    horizontal:
      enabled: true
      maxReplicas: 10
      minReplicas: 1
      targetCPUUtilizationPercentage: 80
      # targetMemoryUtilizationPercentage: 80
  terminationGracePeriodSeconds: 60
  env:
    GORILLA_RUN_UPDATE_SHADOW_QUEUE_SUBSCRIPTIONS_FLAT_RUN_FIELDS_UPDATER:
      value: '{{ include "wandb.runUpdateShadowQueue" . }}'
  envFrom:
    "{{ .Release.Name }}-bucket-configmap": "configMapRef"
    "{{ .Release.Name }}-kafka-configmap": "configMapRef"
    "{{ .Release.Name }}-mysql-configmap": "configMapRef"
    "{{ .Release.Name }}-redis-configmap": "configMapRef"
    "{{ .Release.Name }}-global-secret": "secretRef"
    "{{ .Release.Name }}-flat-run-fields-updater-secret": "secretRef"
    "{{ .Release.Name }}-flat-run-fields-updater-configmap": "configMapRef"
  envTpls:
    - '{{ include "wandb.downwardEnvs" . }}'
    - '{{ include "wandb.bucketEnvs" . }}'
    - '{{ include "wandb.mysqlEnvs" . }}'
    - '{{ include "wandb.redisEnvs" . }}'
    - '{{ include "wandb.queueEnvs" . }}'
    - '{{ include "wandb.historyStoreEnvs" . }}'
  containers:
    flat-run-fields-updater:
      args: ["flat-run-fields-updater"]
      resources:
        limits:
          cpu: "2"
          memory: 4Gi
        requests:
          cpu: "1"
          memory: 1Gi
      volumeMountsTpls:
        - '{{ include "wandb.caCertsVolumeMounts" . }}'
  image:
    repository: wandb/megabinary
    tag: latest
  volumesTpls:
    - '{{ include "wandb.caCertsVolumes" . }}'

filestream:
  install: false
  deploymentPostfix: "bc"
  service:
    enabled: false
  autoscaling:
    horizontal:
      enabled: false
  terminationGracePeriodSeconds: 60
  envFrom:
    "{{ .Release.Name }}-bucket-configmap": "configMapRef"
    "{{ .Release.Name }}-kafka-configmap": "configMapRef"
    "{{ .Release.Name }}-mysql-configmap": "configMapRef"
    "{{ .Release.Name }}-redis-configmap": "configMapRef"
    "{{ .Release.Name }}-global-secret": "secretRef"
    "{{ .Release.Name }}-filestream-secret": "secretRef"
    "{{ .Release.Name }}-filestream-configmap": "configMapRef"
  envTpls:
    - '{{ include "wandb.downwardEnvs" . }}'
    - '{{ include "wandb.bucketEnvs" . }}'
    - '{{ include "wandb.mysqlEnvs" . }}'
    - '{{ include "wandb.redisEnvs" . }}'
    - '{{ include "wandb.queueEnvs" . }}'
    - '{{ include "wandb.historyStoreEnvs" . }}'
  env:
    GORILLA_FILE_STREAM_WORKER_SOURCE_ADDRESS:
      value: '{{ include "wandb.fileStreamStoreConsumer" . }}'
  containers:
    filestream:
      args: ["filestream"]
      requests:
        cpu: 500m
        memory: 4Gi
      limits:
        cpu: 4000m
        memory: 8Gi
      volumeMountsTpls:
        - '{{ include "wandb.caCertsVolumeMounts" . }}'
  image:
    repository: wandb/megabinary
    tag: latest
  volumesTpls:
    - '{{ include "wandb.caCertsVolumes" . }}'

executor:
  install: false
  deploymentPostfix: "bc"
  service:
    enabled: false
  autoscaling:
    horizontal:
      enabled: false
  terminationGracePeriodSeconds: 60
  envFrom:
    "{{ .Release.Name }}-bucket-configmap": "configMapRef"
    "{{ .Release.Name }}-kafka-configmap": "configMapRef"
    "{{ .Release.Name }}-mysql-configmap": "configMapRef"
    "{{ .Release.Name }}-redis-configmap": "configMapRef"
    "{{ .Release.Name }}-global-secret": "secretRef"
    "{{ .Release.Name }}-executor-secret": "secretRef"
    "{{ .Release.Name }}-executor-configmap": "configMapRef"
  envTpls:
    - '{{ include "wandb.downwardEnvs" . }}'
    - '{{ include "wandb.bucketEnvs" . }}'
    - '{{ include "wandb.mysqlEnvs" . }}'
    - '{{ include "wandb.redisEnvs" . }}'
    - '{{ include "wandb.queueEnvs" . }}'
    - '{{ include "wandb.historyStoreEnvs" . }}'
  containers:
    executor:
      args: ["executor"]
      requests:
        cpu: 1
        memory: 2Gi
      limits:
        cpu: 8
        memory: 16Gi
      volumeMountsTpls:
        - '{{ include "wandb.caCertsVolumeMounts" . }}'
  image:
    repository: wandb/megabinary
    tag: latest
  volumesTpls:
    - '{{ include "wandb.caCertsVolumes" . }}'

mysql:
  install: false
  persistence:
    size: 20Gi
    storageClass: ""

yace:
  install: false
  regions: ["ap-south-1"]
  pod:
    annotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "5000"
      prometheus.io/path: "/metrics"
      prometheus.io/scheme: http

redis:
  install: true
  nameOverride: "redis"
  architecture: standalone
  auth:
    enabled: false
    existingSecret: '{{ include "wandb.redis.passwordSecret" . }}'
    existingSecretPasswordKey: "{{ .Values.global.redis.secret.secretKey }}"
  metrics:
    enabled: false
    service:
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "9121"
        prometheus.io/path: "/metrics"

prometheus:
  install: true

  instance:
    install: true

  redis-exporter:
    install: true

  mysql-exporter:
    install: true

stackdriver:
  install: false
  pod:
    annotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "9255"
      prometheus.io/path: "/metrics"
      prometheus.io/scheme: http

otel:
  install: true

  # Consider deploying with a deployment rather than a daemonset to avoid
  # redundant metrics. In setups where both are scraping the same endpoints,
  # this redundancy occurs as both scrape the same points.
  daemonset:
    install: true

  # By default, we use only the daemonset which, along with the Prometheus
  # receiver, gathers most necessary metrics.
  # - To forward Kafka metrics to an external system, you will need to scrape a
  #   promethus endpoint which causes duplicated metrics that get repoted.
  deployment:
    install: false

#   # cannot use install because schema validation will fail.
#   enabled: true

#   resources:
#     limits:
#       cpu: 100m
#       memory: 200M
#   configMap:
#     create: false

#   command:
#     name: otelcol-contrib
#     extraArgs: ["--config=/conf/config.yaml"]
#   extraVolumes:
#     - name: "otel-config"
#       configMap:
#         name: "otel-config"
#         items:
#           - key: config
#             path: config.yaml
#         defaultMode: 420
#   extraVolumeMounts:
#     - name: "otel-config"
#       mountPath: /conf/config.yaml

nameOverride: ""
fullnameOverride: ""

# It is *strongly* recommended to supply passwords yourself for production installs.
kafka:
  install: false
  controller:
    persistence:
      size: 30Gi
  sasl:
    interbroker:
      password: "inter-broker"
    controller:
      password: "controller-pw"
    # The client usernames and passwords are alias references from the global values section at the beginning of this file.
    # Please update the values there to ensure proper propagation to the application
    client:
      users:
        - *kafkaUser
      passwords: *kafkaPassword
    existingSecret: *kafkaSecretName

  kraft:
    # This field is a UUID. It is *strongly* recommended to supply a new UUID yourself for production installs.
    clusterId: "ffFF1H3AQKGdBnsqAbJKew"
  metrics:
    jmx:
      enabled: true

etcd:
  replicaCount: 3
  persistence:
    enabled: true
    size: 10Gi
  autoCompactionMode: periodic
  autoCompactionRetention: 30s
  removeMemberOnContainerTermination: false
  resourcesPreset: none
  auth:
    rbac:
      create: false
      enabled: false
    token:
      enabled: false
  metrics:
    useSeparateEndpoint: true
  customLivenessProbe:
    httpGet:
      port: 9090
      path: /livez
      scheme: "HTTP"
    initialDelaySeconds: 10
    periodSeconds: 30
    timeoutSeconds: 15
    failureThreshold: 10
  customReadinessProbe:
    httpGet:
      port: 9090
      path: /readyz
      scheme: "HTTP"
    initialDelaySeconds: 20
    timeoutSeconds: 10
  extraEnvVars:
    - name: ETCD_LISTEN_CLIENT_HTTP_URLS
      value: "http://0.0.0.0:8080"

bufstream:
  install: false
  storage:
    use: '{{ (include "wandb.bucket" . | fromYaml).provider }}'
    gcs:
      bucket: '{{ include "wandb.bufstream.bucket.name" . }}'
    s3:
      bucket: '{{ include "wandb.bufstream.bucket.name" . }}'
      accessKeyId: '{{ (include "wandb.bucket" . | fromYaml).accessKey }}'
      secretName: '{{ (include "wandb.bucket" . | fromYaml).secretName }}'
      secretKeyName: '{{ (include "wandb.bucket" . | fromYaml).secretKeyName }}'
      region: '{{ (include "wandb.bucket" . | fromYaml).region }}'
      endpoint: '{{ include "wandb.bufstream.bucket.endpoint" . }}'
  metadata:
    use: etcd
    etcd:
      addresses:
        - host: "{{ .Release.Name }}-etcd.{{ .Release.Namespace }}.svc.cluster.local"
          port: 2379
  bufstream:
    deployment:
      resources:
        requests:
          cpu: "1"
          memory: 4Gi

glue:
  # install: false
  imagePullSecrets: *imagePullSecrets
  service:
    enabled: false
  envFrom:
    "{{ .Release.Name }}-bucket-configmap": "configMapRef"
    "{{ .Release.Name }}-mysql-configmap": "configMapRef"
    "{{ .Release.Name }}-redis-configmap": "configMapRef"
    "{{ .Release.Name }}-kafka-configmap": "configMapRef"
    "{{ .Release.Name }}-global-secret": "secretRef"
    "{{ .Release.Name }}-glue-secret": "secretRef"
    "{{ .Release.Name }}-glue-configmap": "configMapRef"
  envTpls:
    - '{{ include "wandb.downwardEnvs" . }}'
    - '{{ include "wandb.bucketEnvs" . }}'
    - '{{ include "wandb.mysqlEnvs" . }}'
    - '{{ include "wandb.redisEnvs" . }}'
    - '{{ include "wandb.queueEnvs" . }}'
    - '{{ include "wandb.historyStoreEnvs" . }}'
  initContainers:
    init-db:
      image:
        repository: wandb/local
        tag: latest
      env:
        MYSQL_HOST:
          value: '{{ include "wandb.mysql.host" . }}'
        MYSQL_DATABASE:
          value: '{{ include "wandb.mysql.database" . }}'
        MYSQL_USER:
          value: '{{ include "wandb.mysql.user" . }}'
        MYSQL_PASSWORD:
          valueFrom:
            secretKeyRef:
              name: '{{ include "wandb.mysql.passwordSecret" . }}'
              key: "{{ .Values.global.mysql.passwordSecret.passwordKey }}"
      command:
        [
          "bash",
          "-c",
          'until mysql -h$MYSQL_HOST -u$MYSQL_USER -p$MYSQL_PASSWORD -D$MYSQL_DATABASE -P$MYSQL_PORT --execute="SELECT 1"; do echo waiting for db; sleep 2; done',
        ]
    migrate-db:
      env:
        MYSQL_HOST:
          value: '{{ include "wandb.mysql.host" . }}'
        MYSQL_DATABASE:
          value: '{{ include "wandb.mysql.database" . }}'
        MYSQL_USER:
          value: '{{ include "wandb.mysql.user" . }}'
        MYSQL_PASSWORD:
          valueFrom:
            secretKeyRef:
              name: '{{ include "wandb.mysql.passwordSecret" . }}'
              key: "{{ .Values.global.mysql.passwordSecret.passwordKey }}"
      command:
        [
          "bash",
          "-c",
          "./megabinary migrate --db=$GORILLA_METADATA_STORE --runs-db=$GORILLA_RUN_STORE || true; ./megabinary migrate --db=$GORILLA_METADATA_STORE --usage-db=$GORILLA_USAGE_STORE || true",
        ]
  containers:
    glue:
      args: ["glue"]
      env: {}
      envFrom: {}
      ports:
        - name: http
          containerPort: 8080
          protocol: TCP
      livenessProbe:
        httpGet:
          path: /healthz
          port: 8080
        initialDelaySeconds: 30
        periodSeconds: 1
        timeoutSeconds: 1
        successThreshold: 1
        failureThreshold: 3
      resources:
        limits:
          cpu: "2"
          memory: 4Gi
        requests:
          cpu: "1"
          memory: 1Gi
      volumeMountsTpls:
        - '{{ include "wandb.caCertsVolumeMounts" . }}'
  image:
    repository: wandb/megabinary
    tag: latest
  role:
    create: true
    rules:
      - apiGroups: [""]
        resources: ["secrets"]
        verbs: ["get", "create", "update", "delete"]
      - apiGroups: [""]
        resources: ["namespaces"]
        verbs: ["get"]
  volumesTpls:
    - '{{ include "wandb.caCertsVolumes" . }}'

api:
  install: false
  imagePullSecrets: *imagePullSecrets
  service:
    enabled: true
    loadBalancerHealthCheckPath: "/ready"
    type: ClusterIP
    ports:
      - port: 8081
        targetPort: api
        protocol: TCP
        name: http
  env: {}
  envFrom:
    "{{ .Release.Name }}-bucket-configmap": "configMapRef"
    "{{ .Release.Name }}-mysql-configmap": "configMapRef"
    "{{ .Release.Name }}-redis-configmap": "configMapRef"
    "{{ .Release.Name }}-kafka-configmap": "configMapRef"
    "{{ .Release.Name }}-global-secret": "secretRef"
    "{{ .Release.Name }}-api-secret": "secretRef"
    "{{ .Release.Name }}-api-configmap": "configMapRef"
    "{{ .Release.Name }}-gorilla-session-key": "secretRef"
  envTpls:
    - '{{ include "wandb.downwardEnvs" . }}'
    - '{{ include "wandb.bucketEnvs" . }}'
    - '{{ include "wandb.mysqlEnvs" . }}'
    - '{{ include "wandb.redisEnvs" . }}'
    - '{{ include "wandb.queueEnvs" . }}'
    - '{{ include "wandb.historyStoreEnvs" . }}'
  initContainers:
    init-db:
      image:
        repository: wandb/local
        tag: latest
      env:
        MYSQL_HOST:
          value: '{{ include "wandb.mysql.host" . }}'
        MYSQL_DATABASE:
          value: '{{ include "wandb.mysql.database" . }}'
        MYSQL_USER:
          value: '{{ include "wandb.mysql.user" . }}'
        MYSQL_PASSWORD:
          valueFrom:
            secretKeyRef:
              name: '{{ include "wandb.mysql.passwordSecret" . }}'
              key: "{{ .Values.global.mysql.passwordSecret.passwordKey }}"
      command:
        [
          "bash",
          "-c",
          'until mysql -h$MYSQL_HOST -u$MYSQL_USER -p$MYSQL_PASSWORD -D$MYSQL_DATABASE -P$MYSQL_PORT --execute="SELECT 1"; do echo waiting for db; sleep 2; done',
        ]
    migrate-db:
      env:
        MYSQL_HOST:
          value: '{{ include "wandb.mysql.host" . }}'
        MYSQL_DATABASE:
          value: '{{ include "wandb.mysql.database" . }}'
        MYSQL_USER:
          value: '{{ include "wandb.mysql.user" . }}'
        MYSQL_PASSWORD:
          valueFrom:
            secretKeyRef:
              name: '{{ include "wandb.mysql.passwordSecret" . }}'
              key: "{{ .Values.global.mysql.passwordSecret.passwordKey }}"
      command:
        [
          "bash",
          "-c",
          "./megabinary migrate --db=$GORILLA_METADATA_STORE --runs-db=$GORILLA_RUN_STORE || true; ./megabinary migrate --db=$GORILLA_METADATA_STORE --usage-db=$GORILLA_USAGE_STORE || true",
        ]
  containers:
    api:
      args: ["gorilla"]
      env: {}
      envFrom: {}
      ports:
        - name: api
          containerPort: 8081
          protocol: TCP
      livenessProbe:
        httpGet:
          path: /healthz
          port: 8081
        initialDelaySeconds: 30
        periodSeconds: 5
        timeoutSeconds: 1
        successThreshold: 1
        failureThreshold: 3
      readinessProbe:
        httpGet:
          path: /ready
          port: api
        periodSeconds: 5
        successThreshold: 1
        failureThreshold: 5
      volumeMountsTpls:
        - '{{ include "wandb.caCertsVolumeMounts" . }}'
  image:
    repository: wandb/megabinary
    tag: latest
  role:
    create: true
    rules:
      - apiGroups: [""]
        resources: ["secrets"]
        verbs: ["get", "create", "update", "delete"]
      - apiGroups: [""]
        resources: ["namespaces"]
        verbs: ["get"]
  volumesTpls:
    - '{{ include "wandb.caCertsVolumes" . }}'
  size: ""
  sizing:
    default:
      resources:
        limits:
          cpu: "4"
          memory: 8Gi
        requests:
          cpu: "2"
          memory: 4Gi
      autoscaling:
        horizontal:
          enabled: true
          maxReplicas: 3
          minReplicas: 1
    small:
      resources:
        limits:
          cpu: "4"
          memory: 8Gi
        requests:
          cpu: "2"
          memory: 4Gi
      autoscaling:
        horizontal:
          enabled: true
          maxReplicas: 2
          minReplicas: 1
    medium:
      resources:
        limits:
          cpu: "4"
          memory: 8Gi
        requests:
          cpu: "2"
          memory: 4Gi
      autoscaling:
        horizontal:
          enabled: true
          maxReplicas: 4
          minReplicas: 2
    large:
      resources:
        limits:
          cpu: "6"
          memory: 16Gi
        requests:
          cpu: "4"
          memory: 12Gi
      autoscaling:
        horizontal:
          enabled: true
          maxReplicas: 6
          minReplicas: 2
    xlarge:
      resources:
        limits:
          cpu: "12"
          memory: 24Gi
        requests:
          cpu: "8"
          memory: 16Gi
      autoscaling:
        horizontal:
          enabled: true
          maxReplicas: 8
          minReplicas: 3
    xxlarge:
      resources:
        limits:
          cpu: "16"
          memory: 32Gi
        requests:
          cpu: "12"
          memory: 24Gi
      autoscaling:
        horizontal:
          enabled: true
          maxReplicas: 10
          minReplicas: 3

filemeta:
  install: false
  imagePullSecrets: *imagePullSecrets
  autoscaling:
    horizontal:
      enabled: true
      maxReplicas: 3
      minReplicas: 2
  image:
    repository: wandb/megabinary
    tag: latest
  env:
    A_REDIS_PASSWORD:
      valueFrom:
        secretKeyRef:
          name: '{{ include "wandb.redis.passwordSecret" . }}'
          key: "{{ .Values.global.redis.secret.secretKey }}"
          optional: true
    A_MYSQL_PASSWORD:
      valueFrom:
        secretKeyRef:
          name: '{{ include "wandb.mysql.passwordSecret" . }}'
          key: "{{ .Values.global.mysql.passwordSecret.passwordKey }}"
    AZURE_STORAGE_KEY:
      valueFrom:
        secretKeyRef:
          name: '{{ (include "wandb.bucket" . | fromYaml).secretName }}'
          key: '{{ (include "wandb.bucket" . | fromYaml).accessKeyName }}'
          optional: true
    BUCKET_ACCESS_KEY:
      valueFrom:
        secretKeyRef:
          name: '{{ (include "wandb.bucket" . | fromYaml).secretName }}'
          key: '{{ (include "wandb.bucket" . | fromYaml).accessKeyName }}'
          optional: true
    BUCKET_SECRET_KEY:
      valueFrom:
        secretKeyRef:
          name: '{{ (include "wandb.bucket" . | fromYaml).secretName }}'
          key: '{{ (include "wandb.bucket" . | fromYaml).secretKeyName }}'
          optional: true
    GORILLA_ONPREM:
      value: "true"
    GORILLA_SETTINGS_CACHE:
      value: '{{ include "wandb.redis.connectionString" . | trim }}'
    GORILLA_FILE_METADATA_SOURCE:
      value: '{{ include "wandb.redis.connectionString" . | trim }}'
    GORILLA_FILE_METADATA_SOURCE_IS_INTERNAL:
      value: "true"
    GORILLA_TASK_QUEUE:
      value: '{{ include "wandb.redis.taskQueue" . | trim }}'
    GORILLA_METADATA_STORE:
      value: '{{ include "wandb.mysql" . | trim }}'
    GORILLA_TRACER:
      value: '{{ include "wandb.otelTracesEndpoint" . | trim }}'
    GORILLA_FILE_STORE:
      value: '{{ (include "wandb.bucket" . | fromYaml).url }}'
    GORILLA_STORAGE_BUCKET:
      value: '{{ (include "wandb.bucket" . | fromYaml).url }}'
  envFrom:
    "{{ .Release.Name }}-bucket-configmap": "configMapRef"
    "{{ .Release.Name }}-mysql-configmap": "configMapRef"
    "{{ .Release.Name }}-redis-configmap": "configMapRef"
    "{{ .Release.Name }}-global-secret": "secretRef"
  containers:
    filemeta:
      args: ["filemeta"]
      env: {}
      envFrom: {}
      resources:
        limits:
          cpu: 1000m
          memory: 1Gi
        requests:
          cpu: 250m
          memory: 256Mi

frontend:
  install: false
  podSecurityContext:
    runAsUser: 101
  autoscaling:
    horizontal:
      enabled: true
      maxReplicas: 3
      minReplicas: 2
  imagePullSecrets: *imagePullSecrets
  image:
    repository: wandb/frontend-nginx
    tag: latest
  volumes:
    - name: wandb-setup-scripts
      configMap:
        name: "{{ .Release.Name }}-frontend-patch-env-js"
        items:
          - key: 02_patch_env_js.sh
            path: 02_patch_env_js.sh
        defaultMode: 0755
  service:
    enabled: true
    loadBalancerHealthCheckPath: "/ready"
    type: ClusterIP
    ports:
      - port: 8080
        targetPort: frontend
        protocol: TCP
        name: http
  env: {}
  envFrom:
    "{{ .Release.Name }}-global-secret": "secretRef"
    "{{ .Release.Name }}-frontend-configmap": "configMapRef"
    "{{ .Release.Name }}-frontend-secret": "secretRef"
  containers:
    frontend:
      env: {}
      envFrom: {}
      ports:
        - name: frontend
          containerPort: 8080
          protocol: TCP
      volumeMounts:
        - name: wandb-setup-scripts
          mountPath: /docker-entrypoint.d/02_patch_env_js.sh
          subPath: 02_patch_env_js.sh
      resources:
        limits:
          cpu: 1000m
          memory: 2Gi
        requests:
          cpu: 100m
          memory: 512Mi

settingsMigrationJob:
  install: false
  imagePullSecrets: *imagePullSecrets
  image:
    repository: wandb/megabinary
    tag: latest
  service:
    enabled: false
  role:
    create: true
    rules:
      - apiGroups:
          - ""
        resources:
          - secrets
        verbs:
          - get
          - create
          - list
          - update
          - patch
  env:
    AZURE_STORAGE_KEY:
      valueFrom:
        secretKeyRef:
          name: '{{ (include "wandb.bucket" . | fromYaml).secretName }}'
          key: '{{ (include "wandb.bucket" . | fromYaml).accessKeyName }}'
          optional: true
    BUCKET_ACCESS_KEY:
      valueFrom:
        secretKeyRef:
          name: '{{ (include "wandb.bucket" . | fromYaml).secretName }}'
          key: '{{ (include "wandb.bucket" . | fromYaml).accessKeyName }}'
          optional: true
    BUCKET_SECRET_KEY:
      valueFrom:
        secretKeyRef:
          name: '{{ (include "wandb.bucket" . | fromYaml).secretName }}'
          key: '{{ (include "wandb.bucket" . | fromYaml).secretKeyName }}'
          optional: true
    SMJ_FILE_STORE:
      value: '{{ (include "wandb.bucket" . | fromYaml).url }}'
    SMJ_K8S_ACTIVE_SPEC_SECRET_NAME:
      value: "wandb-spec-active"
    SMJ_K8S_USER_SPEC_SECRET_NAME:
      value: "wandb-spec-user"
    SMJ_K8S_NAMESPACE:
      valueFrom:
        fieldRef:
          fieldPath: metadata.namespace
  envFrom:
    "{{ .Release.Name }}-bucket-configmap": "configMapRef"
  kind: Job
  jobs:
    smj:
      ttlSecondsAfterFinished: 60
      backoffLimit: 1
      containers:
        smj:
          image:
            repository: wandb/megabinary
            tag: latest
          envFrom:
            "{{ .Release.Name }}-smj-secret": "secretRef"
          args: ["settings-migration-job"]

reloader:
  install: false
  reloader:
    # deployment:
    #   image:
    #     repository: ghcr.io/stakater/reloader
    #     tag: v1.3.0
    watchGlobally: false
    reloadOnCreate: true
    reloadOnDelete: true

clickhouse:
  install: false
  auth:
    existingSecret: '{{ include "wandb.clickhouse.passwordSecret" . }}'
    existingSecretKey: "{{- .Values.global.clickhouse.passwordSecret.passwordKey -}}"

  shards: 1
  replicaCount: 1

  persistentVolumeClaimRetentionPolicy:
    enabled: true
    whenScaled: Retain
    whenDeleted: Retain
  persistence:
    enabled: true
    size: 30Gi
    storageClass: ""

  keeper:
    persistentVolumeClaimRetentionPolicy:
      enabled: true
      whenScaled: Retain
      whenDeleted: Retain
    persistence:
      enabled: true
      size: 8Gi
      storageClass: ""
